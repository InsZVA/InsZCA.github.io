{"posts":[{"title":"对冲基金的收益来源","content":" 在股市里面，如果你不知道谁是韭菜，那么你就是韭菜 证明：对于任意一笔交易，无论是你买了股票，还是卖了股票，你买/卖的时刻一定是有人在以同样的价格卖/买，如果你不明白这里面的奥妙，那么有可能有别人明白，而明白奥妙的人却做着跟你相反的操作，这不是很明显你是韭菜吗？ 那么，对冲基金的收益到底来源于哪里呢？有2部分组成：信息收益和流动性风险收益。 信息收益 制造信息 对冲基金经常收集和制造一些信息，例如收集市场上大量公司的财务信息等，并产出自己对每支股票的分析信息。这些信息可以对基金自己所看多的公司产生向好的建议，以及引导投资者看多。这是第一种信息收益。 获取信息 虽然内幕交易是违法的，但是总而言之，总有一些信息不可能是瞬间被所有投资者知道的，即市场不可能完美高效。如果能更快知道一些信息，一定是有收益的。 套利行为 股票的价格在一些时候并不是完全聚合了所有相关信息的体现，例如公司发布财报等，一般对股票的影响会是一个趋势，而且这个趋势会持续一段时间。而且市场上存在很多投机者，投机者由于自身的流动性风险以及投机心理（追涨杀跌等）导致他们不会立即修正股票的价格，所以会有一段时间的价格偏差，这就存在收益空间。 流动性风险 市场流动性风险 流动性较差的股票，往往会卖更低的价格，因为买股票的人担心买了之后出不了，所以要更低的价格才愿意。另外，在流动性较低的时候，买股票的人和卖股票的人的报价可能会有差距，一部分高频交易者，便是通过高频吸抛，为市场提供流动性，同时自身承担流动性风险，但获得收益。 基金流动性风险 一些股票融资困难，因为他们有较高保证金要求，资本受限的投资者通过基金购买，所以基金可以获得收益。 为巨大的需求压力提供流动性 如果一个股票不寻常地面临大量购买压力，它的价格被抬高，那么意味着它在未来会回报非常低，而其他的股票会被抛弃，导致拥有低价格和高回报。在这种情况下，可以做到低吸高抛。 ","link":"https://InsZVA.github.io/post/dui-chong-ji-jin-de-shou-yi-lai-yuan/"},{"title":"后缀数组的应用理解","content":"前言 字符串一直是短板，之前遇到字符串都是直接跳过，也曾经尝试多次去学习后缀数组，每次都是扫完全文但是不懂。最近终于可以自己用后缀数组去过题目了，简单记录下理解。 构建 构建部分主要是倍增的思想，和一些贪心？结论，具体可以参见OI-wiki,这里就不再赘述。 理解 假设你需要在一个数组中匹配是否出现一个数字，以及这个数字出现了几次，可以采用哈希的方法，也可以采用排序数组的方法。同样，对于一堆字符串，你也可以通过哈希，或者排序数组的方法来解决这类问题。 如果这一堆字符串是一个字符串的所有子串，直接存储O(n)O(n)O(n)个子串需要O(n3)O(n^3)O(n3)的时空复杂度，即使采用哈希也只能降到(O(n2))(O(n^2))(O(n2))。后缀数组就是用下标i来代替整个后缀S[i:]，使得存储只需要O(n)O(n)O(n)复杂度，构建只需要少于O(nlog⁡(n))O(n\\log(n))O(nlog(n))复杂度。但是\b只存后缀怎么来解决对所有子串的操作呢？ 假设我们有一个字符串aabaaaab，他的后缀分别是： aabaaaab abaaaab baaaab aaaab aaab aab ab b 对它们进行排序： aaaab aaab aab aabaaaab ab abaaaab b baaaab 任何一个子串一定是某个后缀的前缀，由于字符串排序实质就是前缀去做比较，所以后缀的排序其实跟所有子串的排序有关，如下： aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab aaab: a &lt; aa &lt; aaa &lt; aaab aab: a &lt; aa &lt; aab aabaaaab: a &lt; aa &lt; aab &lt; aaba &lt; aabaa &lt; aabaaa &lt; aabaaaa &lt; aabaaaab ab: a &lt; ab abaaaab: a &lt; ab &lt; aba &lt; abaa &lt; abaaa &lt; abaaaa &lt; abaaaab b: b baaaab: b &lt; ba &lt; baa &lt; baaa &lt; baaaa &lt; baaaab 但是可以看到，后缀的排序并不完全等于子串的排序，如果我们想知道子串的排序，应该怎么做呢？可以发现对于前3项： aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab aaab: a &lt; aa &lt; aaa &lt; aaab aab: a &lt; aa &lt; aab a和aa这两个子串同时出现在了前3项里面，aaa出现在了前2项里面，与aaa同一列的第3项是aab，aab&gt;aaa。同样可以发现，相邻两个后缀之间有一部分前缀是完全相同的，我们认为这些相同的子串实际在排序中的位置是第一次出现的位置（例如aa应该是第1行第2列），那么我们就得到了所有子串的排序所需要的全部信息。这就是后缀数组的本质：得到所有子串的排序信息。 为了高效处理相邻的两个后缀之间的相同前缀，我们得到了height数组，height[i]=lcp(sa[i-1]. sa[1])，即height数组存了每个后缀和他之前后缀的最长公共前缀。这个height名字取得也很形象，拿上面3项来说： b a b a a b a a a a a a 0 3 2 我们看到height[2]=3,代表了第2个后缀aaab的前缀a和aa和aaa前一项也存在, height[3]=2代表了a和aa在前一个后缀中也存在。这和高度有啥关系呢？在这个例子里面，除去第一项的高度（因为它和空串在做对比）别的都是&gt;=2的，意味着aa及aa的所有前缀存在于所有的后缀中。而对于height[2]=3但是height[3]=2，高度降低了1，意味着aaa这个前缀，在第3个子串之前消失了。 可以发现，所有height记录的都是出现超过1次的子串信息，将这个数组列成直方图： + + + + + + + + + + + + 我们以行视角来看，最底下一行连续出现了5次，然后断开，然后又出现了1次。左边的连续5个代表了a这个子串出现了5+1次，右边的1个代表了b这个子串出现了1次。我们查看原串aabaaaab，的确如此，a出现了6次，b出现了2次。同样我们可以看到高度为2的最开始出现了3次，代表aa这个子串出现了4次。所以**height数组存储了所有出现超过1次的子串的频数信息**。 这里举个应用的例子，我想知道一个字符串里面不同的子串有多少个。每个height[i]=x的代表有x个子串（即S[i:][:x]的所有前缀）在之前已经存在过了，所以我们可以用所有的子串数量n*(n+1)/2减去所有height的和即可得到。 那如果我想知道所有仅出现过一次的不同子串有多少个要怎么做呢？对于S[i:]这个后缀，它和之前之后后缀的LCP，都是不满足的，超过2个LCP的全部满足。所以S[i:]这个后缀的所有只出现过一次的不同子串是len(S[i:])-max(height[i], height[i+1])。全部加起来即可。 如果是想知道所有出现次数为x的子串有多少个要怎么做呢，回到直方图，一行一行来看，第i行连续的长度就是长度为i的子串的出现次数-1。这个就是直方图里面的面积统计，可以用单调栈来做，也可以用分治法来做。我觉得这个单调栈好难写，所以一直都是ST表然后用分治法去做。这里我们可以看出来height数组的名字就是说它可以转为直方图里面的高度，而height数组存储了所有超过1次的子串的频数信息。对于所有子串去统计一些跟子串长度/数量有关系的题目，大多就是这样去做，转化成直方图里面的处理。 ","link":"https://InsZVA.github.io/post/hou-zhui-shu-zu-de-ying-yong-li-jie/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://InsZVA.github.io/post/hello-gridea/"}]}