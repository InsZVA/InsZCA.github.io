{"posts":[{"title":"打造本地量化回测框架","content":"仓位系统 一个简单的字典作为持仓列表，key为标的代码，value为持有股数 class Portfolio: def __init__(self): self.position = collections.defaultdict(int) def update_position(self, code='000001.SZ', hand=100): self.position[code] += hand def get_position(self, code='000001.SZ'): return self.position[code] 仓位信息 单纯仓位系统不能直接开放给策略，策略应该拿到的是一个实际持仓的只读副本。 class PortfolioInfo: def __init__(self, portfolio: Portfolio, start_date: str, end_date: str, date: str, avail_cash: float): self.position = {} for k, v in portfolio.position.items(): self.position[k] = {'hand': v, 'value': Util.get_price(k).close(date) * v * 100} self.avail_cash = avail_cash self.order = [] self.date = date self.start_date = start_date self.end_date = end_date def total_value(self) -&gt; float: res = 0 for k, v in self.position.items(): res += v['value'] return res def rate(self) -&gt; float: return self.total_value() / (self.avail_cash + self.total_value()) def order_by_hand(self, code='000001.SZ', hand=100.): self.order.append({&quot;code&quot;: code, &quot;hand&quot;: hand}) def order_by_cash(self, code='000001.SZ', cash=10000.): self.order.append({&quot;code&quot;: code, &quot;cash&quot;: cash}) 此外，这个信息结构里面还要带上订单系统，供策略调用，策略调用结束后，此结构记录了策略下单的信息，带回模拟器进行模拟购买。 模拟器 模拟器里面主要负责维护一份持仓列表，并提供给策略去做买入卖出操作，操作结束后对策略的下单信息分别进行处理。对于股数/现金买入，计算佣金情况下，二分查找能够在范围内买到的最大数量，对于卖出，计算在佣金印花税消耗下，二分查找最大能卖出的数量处理，处理数量为整百股。另外模拟器在每个交易日的模拟结束后收集仓位信息，最终输出评估表。 class Simulator: def __init__(self, strategy, init_cash=100000., start_date='20200101', end_date='20210101', duty=0.001, brokerage=0.00025): self.init_cash = init_cash self.cash = init_cash self.start_date = start_date self.end_date = end_date self.duty = duty self.brokerage = brokerage self.strategy = strategy self.portfolio = Portfolio() df: pd.DataFrame = pro.trade_cal(start_date=start_date, end_date=end_date) df = df.loc[df['is_open'] == 1] self.trade_dates = list(df['cal_date']) self.date = 0 self.statistics = pd.DataFrame(columns=['date', 'cash', 'stock', 'total', 'rate', 'base']) def _produce_order_hand(self, o: dict, code: str, hand: float, price: float, buy_limit: 0.0): if hand == 0: return price *= 100 if hand &gt; 0: l, r = 0, hand while l &lt; r: m = (l + r + 1) // 2 if price * m + max(price * m * self.brokerage, 5) &lt;= buy_limit: l = m else: r = m - 1 hand = l cost = price * hand + max(price * hand * self.brokerage, 5) logging.info('%s交易成功,买入%d手,花去%f' % (str(o), int(hand), cost)) self.portfolio.update_position(code, hand) self.cash -= cost else: hand = -hand hand = int(min(hand, self.portfolio.get_position(code))) g = price * hand * (1 - self.duty) logging.info('%s交易成功,卖出%d手,得到%f' % (str(o), int(hand), g)) self.portfolio.update_position(code, -hand) self.cash += g def _produce_order(self, info: PortfolioInfo): for o in info.order: price = Util.get_price(o['code']) p = price.open(info.date) if 'hand' in o: self._produce_order_hand(o, o['code'], o['hand'], p, self.cash) elif 'cash' in o: self._produce_order_hand(o, o['code'], o['cash'] // (p * 100), p, o['cash']) else: logging.info('%s非法交易' % (str(o))) def _collect(self): info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash) data = { 'date': self.trade_dates[self.date], 'cash': self.cash, 'stock': info.total_value(), 'total': self.cash + info.total_value(), 'rate': (self.cash + info.total_value()) / self.init_cash - 1, 'base': Util.get_base().get_base(self.start_date, self.trade_dates[self.date]) } self.statistics = self.statistics.append(data, ignore_index=True) logging.info(data) def _open(self, info: PortfolioInfo): self.date += 1 if self.date &gt;= len(self.trade_dates): return self._produce_order(info) self._collect() def _close(self): info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash) self.strategy.on_close(info) self._open(info) def run(self): while self.date &lt; len(self.trade_dates): self._close() f = plt.figure() #ax1 = f.add_subplot() #ax1.plot(self.statistics.index, self.statistics['cash'], label='cash') #ax1.plot(self.statistics.index, self.statistics['stock'], label='stock') #ax1.plot(self.statistics.index, self.statistics['total'], label='total') #ax1.set_title('statistics') #plt.legend() #ax2 = ax1.twinx() def to_percent(temp, position): return '%.2f' % (100 * temp) + '%' #ax2.yaxis.set_major_formatter(FuncFormatter(to_percent)) plt.plot(self.statistics.index, self.statistics['rate'], label='rate') plt.plot(self.statistics.index, self.statistics['base'], label='base') plt.legend() plt.show() 工具类 基准类用于根据沪深300指数来做基准评估，价格类用于获取历史价格。 class Base: def __init__(self, code='ASHS'): file_name = code + &quot;.pkl&quot; if os.path.exists(file_name): self.df = pd.read_pickle(file_name) else: self.df: pd.DataFrame = pro.us_daily(ts_code=code, start_date='20190101', end_date='20210201') self.df = self.df.sort_values('trade_date') self.df.to_pickle(file_name) def get_base(self, start_date: str, end_date: str): y = list(self.df.loc[self.df['trade_date'] &lt;= end_date]['close'])[-1] x = list(self.df.loc[self.df['trade_date'] &lt;= start_date]['close'])[-1] print(start_date, end_date, x, y) return y/x-1 class Price: def __init__(self, code='000001.SZ'): self.code = code self.df: pd.DataFrame = pro.daily(ts_code=code, start_date='20190101', end_date='20210201') def close(self, item): return list(self.df.loc[self.df['trade_date'] == item]['close'])[0] def open(self, item): return list(self.df.loc[self.df['trade_date'] == item]['open'])[0] def get(self, end_date: str): return self.df.loc[self.df['trade_date'] &lt; end_date] 简单策略 这里随便搞了一个（没啥用）的策略，用于测试框架效果。 class MACDStrategy: def __init__(self): self.code = '000001.SZ' def on_close(self, info: PortfolioInfo): p = Util.get_price(self.code) df = p.get(info.date) df = df.sort_values('trade_date') df['ema12'] = df['close'].ewm(span=12).mean() df['ema26'] = df['close'].ewm(span=26).mean() df['diff'] = df['ema12'] - df['ema26'] df['dea'] = df['diff'].ewm(span=9).mean() df['histogram'] = df['diff'] - df['dea'] diff_list = list(df['diff']) if diff_list[-1] &gt; 0 &gt; diff_list[-2]: info.order_by_cash(self.code, info.avail_cash/2) elif diff_list[-1] &lt; 0 &lt; diff_list[-2]: info.order_by_cash(self.code, -info.total_value()/2) 执行效果 2021-02-14 15:51:04,669 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201215', 'cash': 314244.5519999999, 'stock': 818937.9999999999, 'total': 1133182.5519999997, 'rate': 0.13318255199999962, 'base': 0.2669077757685354} 2021-02-14 15:51:04,679 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201216', 'cash': 314244.5519999999, 'stock': 830737.0000000001, 'total': 1144981.5520000001, 'rate': 0.14498155200000018, 'base': 0.26039783001808336} 2021-02-14 15:51:04,689 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201217', 'cash': 314244.5519999999, 'stock': 828115.0, 'total': 1142359.552, 'rate': 0.14235955199999983, 'base': 0.2730560578661847} 2021-02-14 15:51:04,699 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201218', 'cash': 314244.5519999999, 'stock': 802332.0, 'total': 1116576.552, 'rate': 0.11657655199999994, 'base': 0.2600361663652804} 2021-02-14 15:51:04,709 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201221', 'cash': 314244.5519999999, 'stock': 798836.0, 'total': 1113080.552, 'rate': 0.113080552, 'base': 0.27377938517179023} 2021-02-14 15:51:04,719 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201222', 'cash': 314244.5519999999, 'stock': 782229.9999999999, 'total': 1096474.5519999997, 'rate': 0.09647455199999966, 'base': 0.2484629294755878} 2021-02-14 15:51:04,727 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201223', 'cash': 314244.5519999999, 'stock': 786600.0, 'total': 1100844.552, 'rate': 0.10084455199999987, 'base': 0.26075949367088613} 2021-02-14 15:51:04,735 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201224', 'cash': 314244.5519999999, 'stock': 797962.0000000001, 'total': 1112206.5520000001, 'rate': 0.11220655200000018, 'base': 0.24448462929475578} 2021-02-14 15:51:04,740 - /Users/lizile/PycharmProjects/quant/main.py[line:139] - INFO: {'code': '000001.SZ', 'cash': -398981.00000000006}交易成功,卖出220手,得到398900.700000 2021-02-14 15:51:04,744 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201225', 'cash': 713145.2519999999, 'stock': 391468.0, 'total': 1104613.2519999999, 'rate': 0.10461325199999982, 'base': 0.24448462929475578} 2021-02-14 15:51:04,756 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201228', 'cash': 713145.2519999999, 'stock': 409045.0, 'total': 1122190.2519999999, 'rate': 0.12219025199999978, 'base': 0.2484629294755878} 2021-02-14 15:51:04,769 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201229', 'cash': 713145.2519999999, 'stock': 415989.00000000006, 'total': 1129134.2519999999, 'rate': 0.12913425199999984, 'base': 0.24520795660036176} 2021-02-14 15:51:04,784 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201230', 'cash': 713145.2519999999, 'stock': 416639.99999999994, 'total': 1129785.2519999999, 'rate': 0.1297852519999998, 'base': 0.26039783001808336} 2021-02-14 15:51:04,793 - /Users/lizile/PycharmProjects/quant/main.py[line:132] - INFO: {'code': '000001.SZ', 'cash': 356572.62599999993}交易成功,买入187手,花去355388.825000 2021-02-14 15:51:04,800 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201231', 'cash': 357756.42699999985, 'stock': 781336.0, 'total': 1139092.427, 'rate': 0.13909242700000002, 'base': 0.27667269439421327} 完整代码 import logging from functools import lru_cache import os import tushare as ts import pandas as pd from matplotlib import pyplot as plt import collections from matplotlib.ticker import FuncFormatter logging.basicConfig(format='%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s', level=logging.INFO) token = '???' ts.set_token(token) pro = ts.pro_api() class Base: def __init__(self, code='ASHS'): file_name = code + &quot;.pkl&quot; if os.path.exists(file_name): self.df = pd.read_pickle(file_name) else: self.df: pd.DataFrame = pro.us_daily(ts_code=code, start_date='20190101', end_date='20210201') self.df = self.df.sort_values('trade_date') self.df.to_pickle(file_name) def get_base(self, start_date: str, end_date: str): y = list(self.df.loc[self.df['trade_date'] &lt;= end_date]['close'])[-1] x = list(self.df.loc[self.df['trade_date'] &lt;= start_date]['close'])[-1] #print(start_date, end_date, x, y) return y/x-1 class Price: def __init__(self, code='000001.SZ'): self.code = code self.df: pd.DataFrame = pro.daily(ts_code=code, start_date='20190101', end_date='20210201') def close(self, item): return list(self.df.loc[self.df['trade_date'] == item]['close'])[0] def open(self, item): return list(self.df.loc[self.df['trade_date'] == item]['open'])[0] def get(self, end_date: str): return self.df.loc[self.df['trade_date'] &lt; end_date] class Util: @staticmethod @lru_cache(maxsize=None) def get_price(code='000001.SZ') -&gt; Price: return Price(code) @staticmethod @lru_cache(maxsize=None) def get_base(code='ASHS') -&gt; Base: return Base(code) class Portfolio: def __init__(self): self.position = collections.defaultdict(int) def update_position(self, code='000001.SZ', hand=100): self.position[code] += hand def get_position(self, code='000001.SZ'): return self.position[code] class PortfolioInfo: def __init__(self, portfolio: Portfolio, start_date: str, end_date: str, date: str, avail_cash: float): self.position = {} for k, v in portfolio.position.items(): self.position[k] = {'hand': v, 'value': Util.get_price(k).close(date) * v * 100} self.avail_cash = avail_cash self.order = [] self.date = date self.start_date = start_date self.end_date = end_date def total_value(self) -&gt; float: res = 0 for k, v in self.position.items(): res += v['value'] return res def rate(self) -&gt; float: return self.total_value() / (self.avail_cash + self.total_value()) def order_by_hand(self, code='000001.SZ', hand=100.): self.order.append({&quot;code&quot;: code, &quot;hand&quot;: hand}) def order_by_cash(self, code='000001.SZ', cash=10000.): self.order.append({&quot;code&quot;: code, &quot;cash&quot;: cash}) class Simulator: def __init__(self, strategy, init_cash=100000., start_date='20200101', end_date='20210101', duty=0.001, brokerage=0.00025): self.init_cash = init_cash self.cash = init_cash self.start_date = start_date self.end_date = end_date self.duty = duty self.brokerage = brokerage self.strategy = strategy self.portfolio = Portfolio() df: pd.DataFrame = pro.trade_cal(start_date=start_date, end_date=end_date) df = df.loc[df['is_open'] == 1] self.trade_dates = list(df['cal_date']) self.date = 0 self.statistics = pd.DataFrame(columns=['date', 'cash', 'stock', 'total', 'rate', 'base']) def _produce_order_hand(self, o: dict, code: str, hand: float, price: float, buy_limit: 0.0): if hand == 0: return price *= 100 if hand &gt; 0: l, r = 0, hand while l &lt; r: m = (l + r + 1) // 2 if price * m + max(price * m * self.brokerage, 5) &lt;= buy_limit: l = m else: r = m - 1 hand = l cost = price * hand + max(price * hand * self.brokerage, 5) logging.info('%s交易成功,买入%d手,花去%f' % (str(o), int(hand), cost)) self.portfolio.update_position(code, hand) self.cash -= cost else: hand = -hand hand = int(min(hand, self.portfolio.get_position(code))) g = price * hand * (1 - self.duty) logging.info('%s交易成功,卖出%d手,得到%f' % (str(o), int(hand), g)) self.portfolio.update_position(code, -hand) self.cash += g def _produce_order(self, info: PortfolioInfo): for o in info.order: price = Util.get_price(o['code']) p = price.open(info.date) if 'hand' in o: self._produce_order_hand(o, o['code'], o['hand'], p, self.cash) elif 'cash' in o: self._produce_order_hand(o, o['code'], o['cash'] // (p * 100), p, o['cash']) else: logging.info('%s非法交易' % (str(o))) def _collect(self): info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash) data = { 'date': self.trade_dates[self.date], 'cash': self.cash, 'stock': info.total_value(), 'total': self.cash + info.total_value(), 'rate': (self.cash + info.total_value()) / self.init_cash - 1, 'base': Util.get_base().get_base(self.start_date, self.trade_dates[self.date]) } self.statistics = self.statistics.append(data, ignore_index=True) logging.info(data) def _open(self, info: PortfolioInfo): self.date += 1 if self.date &gt;= len(self.trade_dates): return self._produce_order(info) self._collect() def _close(self): info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash) self.strategy.on_close(info) self._open(info) def run(self): while self.date &lt; len(self.trade_dates): self._close() f = plt.figure() #ax1 = f.add_subplot() #ax1.plot(self.statistics.index, self.statistics['cash'], label='cash') #ax1.plot(self.statistics.index, self.statistics['stock'], label='stock') #ax1.plot(self.statistics.index, self.statistics['total'], label='total') #ax1.set_title('statistics') #plt.legend() #ax2 = ax1.twinx() def to_percent(temp, position): return '%.2f' % (100 * temp) + '%' #ax2.yaxis.set_major_formatter(FuncFormatter(to_percent)) plt.plot(self.statistics.index, self.statistics['rate'], label='rate') plt.plot(self.statistics.index, self.statistics['base'], label='base') plt.legend() plt.show() class MACDStrategy: def __init__(self): self.code = '000001.SZ' def on_close(self, info: PortfolioInfo): p = Util.get_price(self.code) df = p.get(info.date) df = df.sort_values('trade_date') df['ema12'] = df['close'].ewm(span=12).mean() df['ema26'] = df['close'].ewm(span=26).mean() df['diff'] = df['ema12'] - df['ema26'] df['dea'] = df['diff'].ewm(span=9).mean() df['histogram'] = df['diff'] - df['dea'] diff_list = list(df['diff']) if diff_list[-1] &gt; 0 &gt; diff_list[-2]: info.order_by_cash(self.code, info.avail_cash/2) elif diff_list[-1] &lt; 0 &lt; diff_list[-2]: info.order_by_cash(self.code, -info.total_value()/2) if __name__ == '__main__': strategy = MACDStrategy() s = Simulator(strategy, 1000000) s.run() ","link":"https://InsZVA.github.io/post/da-zao-ben-di-liang-hua-hui-ce-kuang-jia/"},{"title":"对冲基金的收益来源","content":" 在股市里面，如果你不知道谁是韭菜，那么你就是韭菜 证明：对于任意一笔交易，无论是你买了股票，还是卖了股票，你买/卖的时刻一定是有人在以同样的价格卖/买，如果你不明白这里面的奥妙，那么有可能有别人明白，而明白奥妙的人却做着跟你相反的操作，这不是很明显你是韭菜吗？ 那么，对冲基金的收益到底来源于哪里呢？有2部分组成：信息收益和流动性风险收益。 信息收益 制造信息 对冲基金经常收集和制造一些信息，例如收集市场上大量公司的财务信息等，并产出自己对每支股票的分析信息。这些信息可以对基金自己所看多的公司产生向好的建议，以及引导投资者看多。这是第一种信息收益。 获取信息 虽然内幕交易是违法的，但是总而言之，总有一些信息不可能是瞬间被所有投资者知道的，即市场不可能完美高效。如果能更快知道一些信息，一定是有收益的。 套利行为 股票的价格在一些时候并不是完全聚合了所有相关信息的体现，例如公司发布财报等，一般对股票的影响会是一个趋势，而且这个趋势会持续一段时间。而且市场上存在很多投机者，投机者由于自身的流动性风险以及投机心理（追涨杀跌等）导致他们不会立即修正股票的价格，所以会有一段时间的价格偏差，这就存在收益空间。 流动性风险 市场流动性风险 流动性较差的股票，往往会卖更低的价格，因为买股票的人担心买了之后出不了，所以要更低的价格才愿意。另外，在流动性较低的时候，买股票的人和卖股票的人的报价可能会有差距，一部分高频交易者，便是通过高频吸抛，为市场提供流动性，同时自身承担流动性风险，但获得收益。 基金流动性风险 一些股票融资困难，因为他们有较高保证金要求，资本受限的投资者通过基金购买，所以基金可以获得收益。 为巨大的需求压力提供流动性 如果一个股票不寻常地面临大量购买压力，它的价格被抬高，那么意味着它在未来会回报非常低，而其他的股票会被抛弃，导致拥有低价格和高回报。在这种情况下，可以做到低吸高抛。 ","link":"https://InsZVA.github.io/post/dui-chong-ji-jin-de-shou-yi-lai-yuan/"},{"title":"后缀数组的应用理解","content":"前言 字符串一直是短板，之前遇到字符串都是直接跳过，也曾经尝试多次去学习后缀数组，每次都是扫完全文但是不懂。最近终于可以自己用后缀数组去过题目了，简单记录下理解。 构建 构建部分主要是倍增的思想，和一些贪心？结论，具体可以参见OI-wiki,这里就不再赘述。 理解 假设你需要在一个数组中匹配是否出现一个数字，以及这个数字出现了几次，可以采用哈希的方法，也可以采用排序数组的方法。同样，对于一堆字符串，你也可以通过哈希，或者排序数组的方法来解决这类问题。 如果这一堆字符串是一个字符串的所有子串，直接存储O(n)O(n)O(n)个子串需要O(n3)O(n^3)O(n3)的时空复杂度，即使采用哈希也只能降到(O(n2))(O(n^2))(O(n2))。后缀数组就是用下标i来代替整个后缀S[i:]，使得存储只需要O(n)O(n)O(n)复杂度，构建只需要少于O(nlog⁡(n))O(n\\log(n))O(nlog(n))复杂度。但是\b只存后缀怎么来解决对所有子串的操作呢？ 假设我们有一个字符串aabaaaab，他的后缀分别是： aabaaaab abaaaab baaaab aaaab aaab aab ab b 对它们进行排序： aaaab aaab aab aabaaaab ab abaaaab b baaaab 任何一个子串一定是某个后缀的前缀，由于字符串排序实质就是前缀去做比较，所以后缀的排序其实跟所有子串的排序有关，如下： aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab aaab: a &lt; aa &lt; aaa &lt; aaab aab: a &lt; aa &lt; aab aabaaaab: a &lt; aa &lt; aab &lt; aaba &lt; aabaa &lt; aabaaa &lt; aabaaaa &lt; aabaaaab ab: a &lt; ab abaaaab: a &lt; ab &lt; aba &lt; abaa &lt; abaaa &lt; abaaaa &lt; abaaaab b: b baaaab: b &lt; ba &lt; baa &lt; baaa &lt; baaaa &lt; baaaab 但是可以看到，后缀的排序并不完全等于子串的排序，如果我们想知道子串的排序，应该怎么做呢？可以发现对于前3项： aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab aaab: a &lt; aa &lt; aaa &lt; aaab aab: a &lt; aa &lt; aab a和aa这两个子串同时出现在了前3项里面，aaa出现在了前2项里面，与aaa同一列的第3项是aab，aab&gt;aaa。同样可以发现，相邻两个后缀之间有一部分前缀是完全相同的，我们认为这些相同的子串实际在排序中的位置是第一次出现的位置（例如aa应该是第1行第2列），那么我们就得到了所有子串的排序所需要的全部信息。这就是后缀数组的本质：得到所有子串的排序信息。 为了高效处理相邻的两个后缀之间的相同前缀，我们得到了height数组，height[i]=lcp(sa[i-1]. sa[1])，即height数组存了每个后缀和他之前后缀的最长公共前缀。这个height名字取得也很形象，拿上面3项来说： b a b a a b a a a a a a 0 3 2 我们看到height[2]=3,代表了第2个后缀aaab的前缀a和aa和aaa前一项也存在, height[3]=2代表了a和aa在前一个后缀中也存在。这和高度有啥关系呢？在这个例子里面，除去第一项的高度（因为它和空串在做对比）别的都是&gt;=2的，意味着aa及aa的所有前缀存在于所有的后缀中。而对于height[2]=3但是height[3]=2，高度降低了1，意味着aaa这个前缀，在第3个子串之前消失了。 可以发现，所有height记录的都是出现超过1次的子串信息，将这个数组列成直方图： + + + + + + + + + + + + 我们以行视角来看，最底下一行连续出现了5次，然后断开，然后又出现了1次。左边的连续5个代表了a这个子串出现了5+1次，右边的1个代表了b这个子串出现了1次。我们查看原串aabaaaab，的确如此，a出现了6次，b出现了2次。同样我们可以看到高度为2的最开始出现了3次，代表aa这个子串出现了4次。所以**height数组存储了所有出现超过1次的子串的频数信息**。 这里举个应用的例子，我想知道一个字符串里面不同的子串有多少个。每个height[i]=x的代表有x个子串（即S[i:][:x]的所有前缀）在之前已经存在过了，所以我们可以用所有的子串数量n*(n+1)/2减去所有height的和即可得到。 那如果我想知道所有仅出现过一次的不同子串有多少个要怎么做呢？对于S[i:]这个后缀，它和之前之后后缀的LCP，都是不满足的，超过2个LCP的全部满足。所以S[i:]这个后缀的所有只出现过一次的不同子串是len(S[i:])-max(height[i], height[i+1])。全部加起来即可。 如果是想知道所有出现次数为x的子串有多少个要怎么做呢，回到直方图，一行一行来看，第i行连续的长度就是长度为i的子串的出现次数-1。这个就是直方图里面的面积统计，可以用单调栈来做，也可以用分治法来做。我觉得这个单调栈好难写，所以一直都是ST表然后用分治法去做。这里我们可以看出来height数组的名字就是说它可以转为直方图里面的高度，而height数组存储了所有超过1次的子串的频数信息。对于所有子串去统计一些跟子串长度/数量有关系的题目，大多就是这样去做，转化成直方图里面的处理。 ","link":"https://InsZVA.github.io/post/hou-zhui-shu-zu-de-ying-yong-li-jie/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://InsZVA.github.io/post/hello-gridea/"}]}