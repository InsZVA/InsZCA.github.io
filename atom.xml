<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://InsZVA.github.io</id>
    <title>InsZVA的博客</title>
    <updated>2021-02-14T08:08:45.663Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://InsZVA.github.io"/>
    <link rel="self" href="https://InsZVA.github.io/atom.xml"/>
    <logo>https://InsZVA.github.io/images/avatar.png</logo>
    <icon>https://InsZVA.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, InsZVA的博客</rights>
    <entry>
        <title type="html"><![CDATA[打造本地量化回测框架]]></title>
        <id>https://InsZVA.github.io/post/da-zao-ben-di-liang-hua-hui-ce-kuang-jia/</id>
        <link href="https://InsZVA.github.io/post/da-zao-ben-di-liang-hua-hui-ce-kuang-jia/">
        </link>
        <updated>2021-02-14T07:51:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="仓位系统">仓位系统</h3>
<p>一个简单的字典作为持仓列表，key为标的代码，value为持有股数</p>
<pre><code class="language-python3">class Portfolio:
    def __init__(self):
        self.position = collections.defaultdict(int)

    def update_position(self, code='000001.SZ', hand=100):
        self.position[code] += hand

    def get_position(self, code='000001.SZ'):
        return self.position[code]
</code></pre>
<h3 id="仓位信息">仓位信息</h3>
<p>单纯仓位系统不能直接开放给策略，策略应该拿到的是一个实际持仓的只读副本。</p>
<pre><code class="language-python3">class PortfolioInfo:
    def __init__(self, portfolio: Portfolio, start_date: str, end_date: str, date: str, avail_cash: float):
        self.position = {}
        for k, v in portfolio.position.items():
            self.position[k] = {'hand': v, 'value': Util.get_price(k).close(date) * v * 100}
        self.avail_cash = avail_cash
        self.order = []
        self.date = date
        self.start_date = start_date
        self.end_date = end_date

    def total_value(self) -&gt; float:
        res = 0
        for k, v in self.position.items():
            res += v['value']
        return res

    def rate(self) -&gt; float:
        return self.total_value() / (self.avail_cash + self.total_value())

    def order_by_hand(self, code='000001.SZ', hand=100.):
        self.order.append({&quot;code&quot;: code, &quot;hand&quot;: hand})

    def order_by_cash(self, code='000001.SZ', cash=10000.):
        self.order.append({&quot;code&quot;: code, &quot;cash&quot;: cash})
</code></pre>
<p>此外，这个信息结构里面还要带上订单系统，供策略调用，策略调用结束后，此结构记录了策略下单的信息，带回模拟器进行模拟购买。</p>
<h3 id="模拟器">模拟器</h3>
<p>模拟器里面主要负责维护一份持仓列表，并提供给策略去做买入卖出操作，操作结束后对策略的下单信息分别进行处理。对于股数/现金买入，计算佣金情况下，二分查找能够在范围内买到的最大数量，对于卖出，计算在佣金印花税消耗下，二分查找最大能卖出的数量处理，处理数量为整百股。另外模拟器在每个交易日的模拟结束后收集仓位信息，最终输出评估表。</p>
<pre><code class="language-python3">class Simulator:
    def __init__(self, strategy, init_cash=100000., start_date='20200101', end_date='20210101', duty=0.001,
                 brokerage=0.00025):
        self.init_cash = init_cash
        self.cash = init_cash
        self.start_date = start_date
        self.end_date = end_date
        self.duty = duty
        self.brokerage = brokerage
        self.strategy = strategy
        self.portfolio = Portfolio()
        df: pd.DataFrame = pro.trade_cal(start_date=start_date, end_date=end_date)
        df = df.loc[df['is_open'] == 1]
        self.trade_dates = list(df['cal_date'])
        self.date = 0
        self.statistics = pd.DataFrame(columns=['date', 'cash', 'stock', 'total', 'rate', 'base'])

    def _produce_order_hand(self, o: dict, code: str, hand: float, price: float, buy_limit: 0.0):
        if hand == 0:
            return
        price *= 100
        if hand &gt; 0:
            l, r = 0, hand
            while l &lt; r:
                m = (l + r + 1) // 2
                if price * m + max(price * m * self.brokerage, 5) &lt;= buy_limit:
                    l = m
                else:
                    r = m - 1
            hand = l
            cost = price * hand + max(price * hand * self.brokerage, 5)
            logging.info('%s交易成功,买入%d手,花去%f' % (str(o), int(hand), cost))
            self.portfolio.update_position(code, hand)
            self.cash -= cost
        else:
            hand = -hand
            hand = int(min(hand, self.portfolio.get_position(code)))
            g = price * hand * (1 - self.duty)
            logging.info('%s交易成功,卖出%d手,得到%f' % (str(o), int(hand), g))
            self.portfolio.update_position(code, -hand)
            self.cash += g

    def _produce_order(self, info: PortfolioInfo):
        for o in info.order:
            price = Util.get_price(o['code'])
            p = price.open(info.date)
            if 'hand' in o:
                self._produce_order_hand(o, o['code'], o['hand'], p, self.cash)
            elif 'cash' in o:
                self._produce_order_hand(o, o['code'], o['cash'] // (p * 100), p, o['cash'])
            else:
                logging.info('%s非法交易' % (str(o)))

    def _collect(self):
        info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash)
        data = {
            'date': self.trade_dates[self.date],
            'cash': self.cash,
            'stock': info.total_value(),
            'total': self.cash + info.total_value(),
            'rate': (self.cash + info.total_value()) / self.init_cash - 1,
            'base': Util.get_base().get_base(self.start_date, self.trade_dates[self.date])
        }
        self.statistics = self.statistics.append(data, ignore_index=True)
        logging.info(data)

    def _open(self, info: PortfolioInfo):
        self.date += 1
        if self.date &gt;= len(self.trade_dates):
            return
        self._produce_order(info)
        self._collect()

    def _close(self):
        info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash)
        self.strategy.on_close(info)
        self._open(info)

    def run(self):
        while self.date &lt; len(self.trade_dates):
            self._close()
        f = plt.figure()
        #ax1 = f.add_subplot()
        #ax1.plot(self.statistics.index, self.statistics['cash'], label='cash')
        #ax1.plot(self.statistics.index, self.statistics['stock'], label='stock')
        #ax1.plot(self.statistics.index, self.statistics['total'], label='total')
        #ax1.set_title('statistics')
        #plt.legend()
        #ax2 = ax1.twinx()

        def to_percent(temp, position):
            return '%.2f' % (100 * temp) + '%'

        #ax2.yaxis.set_major_formatter(FuncFormatter(to_percent))
        plt.plot(self.statistics.index, self.statistics['rate'], label='rate')
        plt.plot(self.statistics.index, self.statistics['base'], label='base')
        plt.legend()
        plt.show()
</code></pre>
<h3 id="工具类">工具类</h3>
<p>基准类用于根据沪深300指数来做基准评估，价格类用于获取历史价格。</p>
<pre><code class="language-python3">class Base:
    def __init__(self, code='ASHS'):
        file_name = code + &quot;.pkl&quot;
        if os.path.exists(file_name):
            self.df = pd.read_pickle(file_name)
        else:
            self.df: pd.DataFrame = pro.us_daily(ts_code=code, start_date='20190101', end_date='20210201')
            self.df = self.df.sort_values('trade_date')
            self.df.to_pickle(file_name)

    def get_base(self, start_date: str, end_date: str):
        y = list(self.df.loc[self.df['trade_date'] &lt;= end_date]['close'])[-1]
        x = list(self.df.loc[self.df['trade_date'] &lt;= start_date]['close'])[-1]
        print(start_date, end_date, x, y)
        return y/x-1


class Price:
    def __init__(self, code='000001.SZ'):
        self.code = code
        self.df: pd.DataFrame = pro.daily(ts_code=code, start_date='20190101', end_date='20210201')

    def close(self, item):
        return list(self.df.loc[self.df['trade_date'] == item]['close'])[0]

    def open(self, item):
        return list(self.df.loc[self.df['trade_date'] == item]['open'])[0]

    def get(self, end_date: str):
        return self.df.loc[self.df['trade_date'] &lt; end_date]
</code></pre>
<h3 id="简单策略">简单策略</h3>
<p>这里随便搞了一个（没啥用）的策略，用于测试框架效果。</p>
<pre><code class="language-python3">class MACDStrategy:
    def __init__(self):
        self.code = '000001.SZ'

    def on_close(self, info: PortfolioInfo):
        p = Util.get_price(self.code)
        df = p.get(info.date)
        df = df.sort_values('trade_date')
        df['ema12'] = df['close'].ewm(span=12).mean()
        df['ema26'] = df['close'].ewm(span=26).mean()
        df['diff'] = df['ema12'] - df['ema26']
        df['dea'] = df['diff'].ewm(span=9).mean()
        df['histogram'] = df['diff'] - df['dea']
        diff_list = list(df['diff'])
        if diff_list[-1] &gt; 0 &gt; diff_list[-2]:
            info.order_by_cash(self.code, info.avail_cash/2)
        elif diff_list[-1] &lt; 0 &lt; diff_list[-2]:
            info.order_by_cash(self.code, -info.total_value()/2)
</code></pre>
<h3 id="执行效果">执行效果</h3>
<pre><code>2021-02-14 15:51:04,669 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201215', 'cash': 314244.5519999999, 'stock': 818937.9999999999, 'total': 1133182.5519999997, 'rate': 0.13318255199999962, 'base': 0.2669077757685354}
2021-02-14 15:51:04,679 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201216', 'cash': 314244.5519999999, 'stock': 830737.0000000001, 'total': 1144981.5520000001, 'rate': 0.14498155200000018, 'base': 0.26039783001808336}
2021-02-14 15:51:04,689 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201217', 'cash': 314244.5519999999, 'stock': 828115.0, 'total': 1142359.552, 'rate': 0.14235955199999983, 'base': 0.2730560578661847}
2021-02-14 15:51:04,699 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201218', 'cash': 314244.5519999999, 'stock': 802332.0, 'total': 1116576.552, 'rate': 0.11657655199999994, 'base': 0.2600361663652804}
2021-02-14 15:51:04,709 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201221', 'cash': 314244.5519999999, 'stock': 798836.0, 'total': 1113080.552, 'rate': 0.113080552, 'base': 0.27377938517179023}
2021-02-14 15:51:04,719 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201222', 'cash': 314244.5519999999, 'stock': 782229.9999999999, 'total': 1096474.5519999997, 'rate': 0.09647455199999966, 'base': 0.2484629294755878}
2021-02-14 15:51:04,727 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201223', 'cash': 314244.5519999999, 'stock': 786600.0, 'total': 1100844.552, 'rate': 0.10084455199999987, 'base': 0.26075949367088613}
2021-02-14 15:51:04,735 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201224', 'cash': 314244.5519999999, 'stock': 797962.0000000001, 'total': 1112206.5520000001, 'rate': 0.11220655200000018, 'base': 0.24448462929475578}
2021-02-14 15:51:04,740 - /Users/lizile/PycharmProjects/quant/main.py[line:139] - INFO: {'code': '000001.SZ', 'cash': -398981.00000000006}交易成功,卖出220手,得到398900.700000
2021-02-14 15:51:04,744 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201225', 'cash': 713145.2519999999, 'stock': 391468.0, 'total': 1104613.2519999999, 'rate': 0.10461325199999982, 'base': 0.24448462929475578}
2021-02-14 15:51:04,756 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201228', 'cash': 713145.2519999999, 'stock': 409045.0, 'total': 1122190.2519999999, 'rate': 0.12219025199999978, 'base': 0.2484629294755878}
2021-02-14 15:51:04,769 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201229', 'cash': 713145.2519999999, 'stock': 415989.00000000006, 'total': 1129134.2519999999, 'rate': 0.12913425199999984, 'base': 0.24520795660036176}
2021-02-14 15:51:04,784 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201230', 'cash': 713145.2519999999, 'stock': 416639.99999999994, 'total': 1129785.2519999999, 'rate': 0.1297852519999998, 'base': 0.26039783001808336}
2021-02-14 15:51:04,793 - /Users/lizile/PycharmProjects/quant/main.py[line:132] - INFO: {'code': '000001.SZ', 'cash': 356572.62599999993}交易成功,买入187手,花去355388.825000
2021-02-14 15:51:04,800 - /Users/lizile/PycharmProjects/quant/main.py[line:165] - INFO: {'date': '20201231', 'cash': 357756.42699999985, 'stock': 781336.0, 'total': 1139092.427, 'rate': 0.13909242700000002, 'base': 0.27667269439421327}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://InsZVA.github.io/post-images/1613289932380.png" alt="" loading="lazy"></figure>
<h3 id="完整代码">完整代码</h3>
<pre><code class="language-python3">import logging
from functools import lru_cache
import os
import tushare as ts
import pandas as pd
from matplotlib import pyplot as plt
import collections

from matplotlib.ticker import FuncFormatter

logging.basicConfig(format='%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s',
                    level=logging.INFO)

token = '???'
ts.set_token(token)
pro = ts.pro_api()


class Base:
    def __init__(self, code='ASHS'):
        file_name = code + &quot;.pkl&quot;
        if os.path.exists(file_name):
            self.df = pd.read_pickle(file_name)
        else:
            self.df: pd.DataFrame = pro.us_daily(ts_code=code, start_date='20190101', end_date='20210201')
            self.df = self.df.sort_values('trade_date')
            self.df.to_pickle(file_name)

    def get_base(self, start_date: str, end_date: str):
        y = list(self.df.loc[self.df['trade_date'] &lt;= end_date]['close'])[-1]
        x = list(self.df.loc[self.df['trade_date'] &lt;= start_date]['close'])[-1]
        #print(start_date, end_date, x, y)
        return y/x-1


class Price:
    def __init__(self, code='000001.SZ'):
        self.code = code
        self.df: pd.DataFrame = pro.daily(ts_code=code, start_date='20190101', end_date='20210201')

    def close(self, item):
        return list(self.df.loc[self.df['trade_date'] == item]['close'])[0]

    def open(self, item):
        return list(self.df.loc[self.df['trade_date'] == item]['open'])[0]

    def get(self, end_date: str):
        return self.df.loc[self.df['trade_date'] &lt; end_date]


class Util:
    @staticmethod
    @lru_cache(maxsize=None)
    def get_price(code='000001.SZ') -&gt; Price:
        return Price(code)

    @staticmethod
    @lru_cache(maxsize=None)
    def get_base(code='ASHS') -&gt; Base:
        return Base(code)


class Portfolio:
    def __init__(self):
        self.position = collections.defaultdict(int)

    def update_position(self, code='000001.SZ', hand=100):
        self.position[code] += hand

    def get_position(self, code='000001.SZ'):
        return self.position[code]


class PortfolioInfo:
    def __init__(self, portfolio: Portfolio, start_date: str, end_date: str, date: str, avail_cash: float):
        self.position = {}
        for k, v in portfolio.position.items():
            self.position[k] = {'hand': v, 'value': Util.get_price(k).close(date) * v * 100}
        self.avail_cash = avail_cash
        self.order = []
        self.date = date
        self.start_date = start_date
        self.end_date = end_date

    def total_value(self) -&gt; float:
        res = 0
        for k, v in self.position.items():
            res += v['value']
        return res

    def rate(self) -&gt; float:
        return self.total_value() / (self.avail_cash + self.total_value())

    def order_by_hand(self, code='000001.SZ', hand=100.):
        self.order.append({&quot;code&quot;: code, &quot;hand&quot;: hand})

    def order_by_cash(self, code='000001.SZ', cash=10000.):
        self.order.append({&quot;code&quot;: code, &quot;cash&quot;: cash})


class Simulator:
    def __init__(self, strategy, init_cash=100000., start_date='20200101', end_date='20210101', duty=0.001,
                 brokerage=0.00025):
        self.init_cash = init_cash
        self.cash = init_cash
        self.start_date = start_date
        self.end_date = end_date
        self.duty = duty
        self.brokerage = brokerage
        self.strategy = strategy
        self.portfolio = Portfolio()
        df: pd.DataFrame = pro.trade_cal(start_date=start_date, end_date=end_date)
        df = df.loc[df['is_open'] == 1]
        self.trade_dates = list(df['cal_date'])
        self.date = 0
        self.statistics = pd.DataFrame(columns=['date', 'cash', 'stock', 'total', 'rate', 'base'])

    def _produce_order_hand(self, o: dict, code: str, hand: float, price: float, buy_limit: 0.0):
        if hand == 0:
            return
        price *= 100
        if hand &gt; 0:
            l, r = 0, hand
            while l &lt; r:
                m = (l + r + 1) // 2
                if price * m + max(price * m * self.brokerage, 5) &lt;= buy_limit:
                    l = m
                else:
                    r = m - 1
            hand = l
            cost = price * hand + max(price * hand * self.brokerage, 5)
            logging.info('%s交易成功,买入%d手,花去%f' % (str(o), int(hand), cost))
            self.portfolio.update_position(code, hand)
            self.cash -= cost
        else:
            hand = -hand
            hand = int(min(hand, self.portfolio.get_position(code)))
            g = price * hand * (1 - self.duty)
            logging.info('%s交易成功,卖出%d手,得到%f' % (str(o), int(hand), g))
            self.portfolio.update_position(code, -hand)
            self.cash += g

    def _produce_order(self, info: PortfolioInfo):
        for o in info.order:
            price = Util.get_price(o['code'])
            p = price.open(info.date)
            if 'hand' in o:
                self._produce_order_hand(o, o['code'], o['hand'], p, self.cash)
            elif 'cash' in o:
                self._produce_order_hand(o, o['code'], o['cash'] // (p * 100), p, o['cash'])
            else:
                logging.info('%s非法交易' % (str(o)))

    def _collect(self):
        info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash)
        data = {
            'date': self.trade_dates[self.date],
            'cash': self.cash,
            'stock': info.total_value(),
            'total': self.cash + info.total_value(),
            'rate': (self.cash + info.total_value()) / self.init_cash - 1,
            'base': Util.get_base().get_base(self.start_date, self.trade_dates[self.date])
        }
        self.statistics = self.statistics.append(data, ignore_index=True)
        logging.info(data)

    def _open(self, info: PortfolioInfo):
        self.date += 1
        if self.date &gt;= len(self.trade_dates):
            return
        self._produce_order(info)
        self._collect()

    def _close(self):
        info = PortfolioInfo(self.portfolio, self.start_date, self.end_date, self.trade_dates[self.date], self.cash)
        self.strategy.on_close(info)
        self._open(info)

    def run(self):
        while self.date &lt; len(self.trade_dates):
            self._close()
        f = plt.figure()
        #ax1 = f.add_subplot()
        #ax1.plot(self.statistics.index, self.statistics['cash'], label='cash')
        #ax1.plot(self.statistics.index, self.statistics['stock'], label='stock')
        #ax1.plot(self.statistics.index, self.statistics['total'], label='total')
        #ax1.set_title('statistics')
        #plt.legend()
        #ax2 = ax1.twinx()

        def to_percent(temp, position):
            return '%.2f' % (100 * temp) + '%'

        #ax2.yaxis.set_major_formatter(FuncFormatter(to_percent))
        plt.plot(self.statistics.index, self.statistics['rate'], label='rate')
        plt.plot(self.statistics.index, self.statistics['base'], label='base')
        plt.legend()
        plt.show()


class MACDStrategy:
    def __init__(self):
        self.code = '000001.SZ'

    def on_close(self, info: PortfolioInfo):
        p = Util.get_price(self.code)
        df = p.get(info.date)
        df = df.sort_values('trade_date')
        df['ema12'] = df['close'].ewm(span=12).mean()
        df['ema26'] = df['close'].ewm(span=26).mean()
        df['diff'] = df['ema12'] - df['ema26']
        df['dea'] = df['diff'].ewm(span=9).mean()
        df['histogram'] = df['diff'] - df['dea']
        diff_list = list(df['diff'])
        if diff_list[-1] &gt; 0 &gt; diff_list[-2]:
            info.order_by_cash(self.code, info.avail_cash/2)
        elif diff_list[-1] &lt; 0 &lt; diff_list[-2]:
            info.order_by_cash(self.code, -info.total_value()/2)


if __name__ == '__main__':
    strategy = MACDStrategy()
    s = Simulator(strategy, 1000000)
    s.run()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对冲基金的收益来源]]></title>
        <id>https://InsZVA.github.io/post/dui-chong-ji-jin-de-shou-yi-lai-yuan/</id>
        <link href="https://InsZVA.github.io/post/dui-chong-ji-jin-de-shou-yi-lai-yuan/">
        </link>
        <updated>2020-11-28T11:05:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在股市里面，如果你不知道谁是韭菜，那么你就是韭菜</p>
</blockquote>
<p>证明：对于任意一笔交易，无论是你买了股票，还是卖了股票，你买/卖的时刻一定是有人在以同样的价格卖/买，如果你不明白这里面的奥妙，那么有可能有别人明白，而明白奥妙的人却做着跟你相反的操作，这不是很明显你是韭菜吗？</p>
<p>那么，对冲基金的收益到底来源于哪里呢？有2部分组成：信息收益和流动性风险收益。</p>
<h3 id="信息收益">信息收益</h3>
<h4 id="制造信息">制造信息</h4>
<p>对冲基金经常收集和制造一些信息，例如收集市场上大量公司的财务信息等，并产出自己对每支股票的分析信息。这些信息可以对基金自己所看多的公司产生向好的建议，以及引导投资者看多。这是第一种信息收益。</p>
<h4 id="获取信息">获取信息</h4>
<p>虽然内幕交易是违法的，但是总而言之，总有一些信息不可能是瞬间被所有投资者知道的，即市场不可能完美高效。如果能更快知道一些信息，一定是有收益的。</p>
<h4 id="套利行为">套利行为</h4>
<p>股票的价格在一些时候并不是完全聚合了所有相关信息的体现，例如公司发布财报等，一般对股票的影响会是一个趋势，而且这个趋势会持续一段时间。而且市场上存在很多投机者，投机者由于自身的流动性风险以及投机心理（追涨杀跌等）导致他们不会立即修正股票的价格，所以会有一段时间的价格偏差，这就存在收益空间。</p>
<h3 id="流动性风险">流动性风险</h3>
<h4 id="市场流动性风险">市场流动性风险</h4>
<p>流动性较差的股票，往往会卖更低的价格，因为买股票的人担心买了之后出不了，所以要更低的价格才愿意。另外，在流动性较低的时候，买股票的人和卖股票的人的报价可能会有差距，一部分高频交易者，便是通过高频吸抛，为市场提供流动性，同时自身承担流动性风险，但获得收益。</p>
<h4 id="基金流动性风险">基金流动性风险</h4>
<p>一些股票融资困难，因为他们有较高保证金要求，资本受限的投资者通过基金购买，所以基金可以获得收益。</p>
<h4 id="为巨大的需求压力提供流动性">为巨大的需求压力提供流动性</h4>
<p>如果一个股票不寻常地面临大量购买压力，它的价格被抬高，那么意味着它在未来会回报非常低，而其他的股票会被抛弃，导致拥有低价格和高回报。在这种情况下，可以做到低吸高抛。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后缀数组的应用理解]]></title>
        <id>https://InsZVA.github.io/post/hou-zhui-shu-zu-de-ying-yong-li-jie/</id>
        <link href="https://InsZVA.github.io/post/hou-zhui-shu-zu-de-ying-yong-li-jie/">
        </link>
        <updated>2020-11-13T11:25:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>字符串一直是短板，之前遇到字符串都是直接跳过，也曾经尝试多次去学习后缀数组，每次都是扫完全文但是不懂。最近终于可以自己用后缀数组去过题目了，简单记录下理解。</p>
<h2 id="构建">构建</h2>
<p>构建部分主要是倍增的思想，和一些贪心？结论，具体可以参见<a href="https://oi-wiki.org/string/sa/">OI-wiki</a>,这里就不再赘述。</p>
<h2 id="理解">理解</h2>
<p>假设你需要在一个数组中匹配是否出现一个数字，以及这个数字出现了几次，可以采用哈希的方法，也可以采用排序数组的方法。同样，对于一堆字符串，你也可以通过哈希，或者排序数组的方法来解决这类问题。<br>
如果这一堆字符串是一个字符串的所有子串，直接存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个子串需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时空复杂度，即使采用哈希也只能降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(O(n^2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。后缀数组就是用下标<code>i</code>来代替整个后缀<code>S[i:]</code>，使得存储只需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>复杂度，构建只需要少于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>复杂度。但是只存后缀怎么来解决对所有子串的操作呢？<br>
假设我们有一个字符串<code>aabaaaab</code>，他的后缀分别是：</p>
<pre><code>aabaaaab
abaaaab
baaaab
aaaab
aaab
aab
ab
b
</code></pre>
<p>对它们进行排序：</p>
<pre><code>aaaab
aaab
aab
aabaaaab
ab
abaaaab
b
baaaab
</code></pre>
<p><strong>任何一个子串一定是某个后缀的前缀</strong>，由于字符串排序实质就是前缀去做比较，所以后缀的排序其实跟所有子串的排序有关，如下：</p>
<pre><code>aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab
aaab: a &lt; aa &lt; aaa &lt; aaab
aab: a &lt; aa &lt; aab
aabaaaab: a &lt; aa &lt; aab &lt; aaba &lt; aabaa &lt; aabaaa &lt; aabaaaa &lt; aabaaaab
ab: a &lt; ab
abaaaab: a &lt; ab &lt; aba &lt; abaa &lt; abaaa &lt; abaaaa &lt; abaaaab
b: b
baaaab: b &lt; ba &lt; baa &lt; baaa &lt; baaaa &lt; baaaab
</code></pre>
<p>但是可以看到，后缀的排序并不完全等于子串的排序，如果我们想知道子串的排序，应该怎么做呢？可以发现对于前3项：</p>
<pre><code>aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab
aaab: a &lt; aa &lt; aaa &lt; aaab
aab: a &lt; aa &lt; aab
</code></pre>
<p>a和aa这两个子串同时出现在了前3项里面，aaa出现在了前2项里面，与aaa同一列的第3项是aab，aab&gt;aaa。同样可以发现，相邻两个后缀之间有一部分前缀是完全相同的，我们认为这些相同的子串实际在排序中的位置是第一次出现的位置（例如aa应该是第1行第2列），那么我们就得到了所有子串的排序所需要的全部信息。这就是后缀数组的本质：得到所有子串的排序信息。<br>
为了高效处理相邻的两个后缀之间的相同前缀，我们得到了<code>height</code>数组，<code>height[i]=lcp(sa[i-1]. sa[1])</code>，即<code>height</code>数组存了每个后缀和他之前后缀的最长公共前缀。这个<code>height</code>名字取得也很形象，拿上面3项来说：</p>
<pre><code>b
a b
a a b
a a a
a a a
0 3 2
</code></pre>
<p>我们看到<code>height[2]=3</code>,代表了第2个后缀<code>aaab</code>的前缀<code>a</code>和<code>aa</code>和<code>aaa</code>前一项也存在, <code>height[3]=2</code>代表了<code>a</code>和<code>aa</code>在前一个后缀中也存在。这和高度有啥关系呢？在这个例子里面，除去第一项的高度（因为它和空串在做对比）别的都是&gt;=2的，意味着<code>aa</code>及<code>aa</code>的所有前缀存在于所有的后缀中。而对于<code>height[2]=3</code>但是<code>height[3]=2</code>，高度降低了1，意味着<code>aaa</code>这个前缀，在第3个子串之前消失了。<br>
可以发现，所有<code>height</code>记录的都是出现超过1次的子串信息，将这个数组列成直方图：</p>
<pre><code> +   +
 + + +   +
 + + + + +   +
</code></pre>
<p>我们以行视角来看，最底下一行连续出现了5次，然后断开，然后又出现了1次。左边的连续5个代表了<code>a</code>这个子串出现了5+1次，右边的1个代表了<code>b</code>这个子串出现了1次。我们查看原串<code>aabaaaab</code>，的确如此，<code>a</code>出现了6次，<code>b</code>出现了2次。同样我们可以看到高度为2的最开始出现了3次，代表<code>aa</code>这个子串出现了4次。所以**<code>height</code>数组存储了所有出现超过1次的子串的频数信息**。<br>
这里举个应用的例子，我想知道一个字符串里面不同的子串有多少个。每个<code>height[i]=x</code>的代表有<code>x</code>个子串（即<code>S[i:][:x]</code>的所有前缀）在之前已经存在过了，所以我们可以用所有的子串数量<code>n*(n+1)/2</code>减去所有<code>height</code>的和即可得到。<br>
那如果我想知道所有仅出现过一次的不同子串有多少个要怎么做呢？对于<code>S[i:]</code>这个后缀，它和之前之后后缀的LCP，都是不满足的，超过2个LCP的全部满足。所以<code>S[i:]</code>这个后缀的所有只出现过一次的不同子串是<code>len(S[i:])-max(height[i], height[i+1])</code>。全部加起来即可。<br>
如果是想知道所有出现次数为<code>x</code>的子串有多少个要怎么做呢，回到直方图，一行一行来看，第i行连续的长度就是长度为i的子串的出现次数-1。这个就是直方图里面的面积统计，可以用单调栈来做，也可以用分治法来做。我觉得这个单调栈好难写，所以一直都是ST表然后用分治法去做。这里我们可以看出来<code>height</code>数组的名字就是说它可以转为直方图里面的高度，而<code>height</code>数组存储了所有超过1次的子串的频数信息。对于所有子串去统计一些跟子串长度/数量有关系的题目，大多就是这样去做，转化成直方图里面的处理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://InsZVA.github.io/post/hello-gridea/</id>
        <link href="https://InsZVA.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>