<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://InsZVA.github.io</id>
    <title>InsZVA的博客</title>
    <updated>2020-11-13T12:31:13.245Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://InsZVA.github.io"/>
    <link rel="self" href="https://InsZVA.github.io/atom.xml"/>
    <logo>https://InsZVA.github.io/images/avatar.png</logo>
    <icon>https://InsZVA.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, InsZVA的博客</rights>
    <entry>
        <title type="html"><![CDATA[后缀数组的应用理解]]></title>
        <id>https://InsZVA.github.io/post/hou-zhui-shu-zu-de-ying-yong-li-jie/</id>
        <link href="https://InsZVA.github.io/post/hou-zhui-shu-zu-de-ying-yong-li-jie/">
        </link>
        <updated>2020-11-13T11:25:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>字符串一直是短板，之前遇到字符串都是直接跳过，也曾经尝试多次去学习后缀数组，每次都是扫完全文但是不懂。最近终于可以自己用后缀数组去过题目了，简单记录下理解。</p>
<h2 id="构建">构建</h2>
<p>构建部分主要是倍增的思想，和一些贪心？结论，具体可以参见<a href="https://oi-wiki.org/string/sa/">OI-wiki</a>,这里就不再赘述。</p>
<h2 id="理解">理解</h2>
<p>假设你需要在一个数组中匹配是否出现一个数字，以及这个数字出现了几次，可以采用哈希的方法，也可以采用排序数组的方法。同样，对于一堆字符串，你也可以通过哈希，或者排序数组的方法来解决这类问题。<br>
如果这一堆字符串是一个字符串的所有子串，直接存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>个子串需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时空复杂度，即使采用哈希也只能降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">(O(n^2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。后缀数组就是用下标<code>i</code>来代替整个后缀<code>S[i:]</code>，使得存储只需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>复杂度，构建只需要少于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>复杂度。但是只存后缀怎么来解决对所有子串的操作呢？<br>
假设我们有一个字符串<code>aabaaaab</code>，他的后缀分别是：</p>
<pre><code>aabaaaab
abaaaab
baaaab
aaaab
aaab
aab
ab
b
</code></pre>
<p>对它们进行排序：</p>
<pre><code>aaaab
aaab
aab
aabaaaab
ab
abaaaab
b
baaaab
</code></pre>
<p><strong>任何一个子串一定是某个后缀的前缀</strong>，由于字符串排序实质就是前缀去做比较，所以后缀的排序其实跟所有子串的排序有关，如下：</p>
<pre><code>aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab
aaab: a &lt; aa &lt; aaa &lt; aaab
aab: a &lt; aa &lt; aab
aabaaaab: a &lt; aa &lt; aab &lt; aaba &lt; aabaa &lt; aabaaa &lt; aabaaaa &lt; aabaaaab
ab: a &lt; ab
abaaaab: a &lt; ab &lt; aba &lt; abaa &lt; abaaa &lt; abaaaa &lt; abaaaab
b: b
baaaab: b &lt; ba &lt; baa &lt; baaa &lt; baaaa &lt; baaaab
</code></pre>
<p>但是可以看到，后缀的排序并不完全等于子串的排序，如果我们想知道子串的排序，应该怎么做呢？可以发现对于前3项：</p>
<pre><code>aaaab: a &lt; aa &lt; aaa &lt; aaaa &lt; aaaab
aaab: a &lt; aa &lt; aaa &lt; aaab
aab: a &lt; aa &lt; aab
</code></pre>
<p>a和aa这两个子串同时出现在了前3项里面，aaa出现在了前2项里面，与aaa同一列的第3项是aab，aab&gt;aaa。同样可以发现，相邻两个后缀之间有一部分前缀是完全相同的，我们认为这些相同的子串实际在排序中的位置是第一次出现的位置（例如aa应该是第1行第2列），那么我们就得到了所有子串的排序所需要的全部信息。这就是后缀数组的本质：得到所有子串的排序信息。<br>
为了高效处理相邻的两个后缀之间的相同前缀，我们得到了<code>height</code>数组，<code>height[i]=lcp(sa[i-1]. sa[1])</code>，即<code>height</code>数组存了每个后缀和他之前后缀的最长公共前缀。这个<code>height</code>名字取得也很形象，拿上面3项来说：</p>
<pre><code>b
a b
a a b
a a a
a a a
0 3 2
</code></pre>
<p>我们看到<code>height[2]=3</code>,代表了第2个后缀<code>aaab</code>的前缀<code>a</code>和<code>aa</code>和<code>aaa</code>前一项也存在, <code>height[3]=2</code>代表了<code>a</code>和<code>aa</code>在前一个后缀中也存在。这和高度有啥关系呢？在这个例子里面，除去第一项的高度（因为它和空串在做对比）别的都是&gt;=2的，意味着<code>aa</code>及<code>aa</code>的所有前缀存在于所有的后缀中。而对于<code>height[2]=3</code>但是<code>height[3]=2</code>，高度降低了1，意味着<code>aaa</code>这个前缀，在第3个子串之前消失了。<br>
可以发现，所有<code>height</code>记录的都是出现超过1次的子串信息，将这个数组列成直方图：</p>
<pre><code> +   +
 + + +   +
 + + + + +   +
</code></pre>
<p>我们以行视角来看，最底下一行连续出现了5次，然后断开，然后又出现了1次。左边的连续5个代表了<code>a</code>这个子串出现了5+1次，右边的1个代表了<code>b</code>这个子串出现了1次。我们查看原串<code>aabaaaab</code>，的确如此，<code>a</code>出现了6次，<code>b</code>出现了2次。同样我们可以看到高度为2的最开始出现了3次，代表<code>aa</code>这个子串出现了4次。所以**<code>height</code>数组存储了所有出现超过1次的子串的频数信息**。<br>
这里举个应用的例子，我想知道一个字符串里面不同的子串有多少个。每个<code>height[i]=x</code>的代表有<code>x</code>个子串（即<code>S[i:][:x]</code>的所有前缀）在之前已经存在过了，所以我们可以用所有的子串数量<code>n*(n+1)/2</code>减去所有<code>height</code>的和即可得到。<br>
那如果我想知道所有仅出现过一次的不同子串有多少个要怎么做呢？对于<code>S[i:]</code>这个后缀，它和之前之后后缀的LCP，都是不满足的，超过2个LCP的全部满足。所以<code>S[i:]</code>这个后缀的所有只出现过一次的不同子串是<code>len(S[i:])-max(height[i], height[i+1])</code>。全部加起来即可。<br>
如果是想知道所有出现次数为<code>x</code>的子串有多少个要怎么做呢，回到直方图，一行一行来看，第i行连续的长度就是长度为i的子串的出现次数-1。这个就是直方图里面的面积统计，可以用单调栈来做，也可以用分治法来做。我觉得这个单调栈好难写，所以一直都是ST表然后用分治法去做。这里我们可以看出来<code>height</code>数组的名字就是说它可以转为直方图里面的高度，而<code>height</code>数组存储了所有超过1次的子串的频数信息。对于所有子串去统计一些跟子串长度/数量有关系的题目，大多就是这样去做，转化成直方图里面的处理。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://InsZVA.github.io/post/hello-gridea/</id>
        <link href="https://InsZVA.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>